import java.io.IOException;
import java.io.Reader;
import java.io.StringReader;

/** Jam Interpreter */
class Interpreter {
    
    public static void main(String[] args) {
        try {
            //String program = "let a := 2; b := map x to a * x; c := 5; in ((map x to if x < 3 then b else c)(a))(7)";
            //String program = "let a := c; b := a + 100; c := b + 100; in (map x to if x < 3 then b else c)(a)";
            //String program = "let a := c; b := a+1; c := b+2; in (map x to if x < 3 then b else c)(a)";
            String program = "let zeroes := cons(0,zeroes); in first(rest(zeroes))";
            Parser parser = new Parser(new StringReader(program));
            AST ast = parser.parse();
            Context.check(ast);
            Interpreter interp = new Interpreter(ast);
            System.out.println(interp.valueName());
            System.out.println("success");
        }
        catch (Exception e) {
            e.printStackTrace();
        }
    }

    /** Abstract Syntax Tree generated by the parser */
    private AST ast;

    /** Constructor */
    Interpreter(String fileName) throws IOException { this(new Parser(fileName)); }

    /** Constructor */
    Interpreter(Reader reader) { this(new Parser(reader)); }

    /** Constructor */
    Interpreter(Parser p) { this(p.parse()); }

    /** Constructor */
    Interpreter(AST ast) { this.ast = ast; }

    /** Interprets the program using a call-by-value calling convention (with a default cons-by-value cons convention) */
    public JamVal callByValue() {
        Context.check(ast);
        return this.ast.accept(
                new ASTInterpreter(
                        new Empty<Binding>(),
                        new EvaluationPolicy(EvaluationType.BY_VALUE, EvaluationType.BY_VALUE)
                        )
                );
    }

    /** Interprets the program using a call-by-name calling convention (with a default cons-by-value cons convention) */
    public JamVal callByName() {
        Context.check(ast);
        return this.ast.accept(
                new ASTInterpreter(
                        new Empty<Binding>(),
                        new EvaluationPolicy(EvaluationType.BY_NAME, EvaluationType.BY_VALUE)
                        )
                );
    }

    /** Interprets the program using a call-by-need calling convention (with a default cons-by-value cons convention) */
    public JamVal callByNeed() {
        Context.check(ast);
        return this.ast.accept(
                new ASTInterpreter(
                        new Empty<Binding>(),
                        new EvaluationPolicy(EvaluationType.BY_NEED, EvaluationType.BY_VALUE)
                        )
                );
    }
    
    /** Interprets the program using a call-by-value calling convention and a cons-by-value cons convention */
    public JamVal valueValue() {
        Context.check(ast);
        return this.ast.accept(
                new ASTInterpreter(
                        new Empty<Binding>(),
                        new EvaluationPolicy(EvaluationType.BY_VALUE, EvaluationType.BY_VALUE)
                        )
                );
    }

    /** Interprets the program using a call-by-name calling convention and a cons-by-value cons convention */
    public JamVal nameValue() {
        Context.check(ast);
        return this.ast.accept(
                new ASTInterpreter(
                        new Empty<Binding>(),
                        new EvaluationPolicy(EvaluationType.BY_NAME, EvaluationType.BY_VALUE)
                        )
                );
    }

    /** Interprets the program using a call-by-need calling convention and a cons-by-value cons convention */
    public JamVal needValue() {
        Context.check(ast);
        return this.ast.accept(
                new ASTInterpreter(
                        new Empty<Binding>(),
                        new EvaluationPolicy(EvaluationType.BY_NEED, EvaluationType.BY_VALUE)
                        )
                );
    }

    /** Interprets the program using a call-by-value calling convention and a cons-by-name cons convention */
    public JamVal valueName() {
        Context.check(ast);
        return this.ast.accept(
                new ASTInterpreter(
                        new Empty<Binding>(),
                        new EvaluationPolicy(EvaluationType.BY_VALUE, EvaluationType.BY_NAME)
                        )
                );
    }

    /** Interprets the program using a call-by-name calling convention and a cons-by-name cons convention */
    public JamVal nameName() {
        Context.check(ast);
        return this.ast.accept(
                new ASTInterpreter(
                        new Empty<Binding>(),
                        new EvaluationPolicy(EvaluationType.BY_NAME, EvaluationType.BY_NAME)
                        )
                );
    }

    /** Interprets the program using a call-by-need calling convention and a cons-by-name cons convention */
    public JamVal needName() {
        Context.check(ast);
        return this.ast.accept(
                new ASTInterpreter(
                        new Empty<Binding>(),
                        new EvaluationPolicy(EvaluationType.BY_NEED, EvaluationType.BY_NAME)
                        )
                );
    }

    /** Interprets the program using a call-by-value calling convention and a cons-by-need cons convention */
    public JamVal valueNeed() {
        Context.check(ast);
        return this.ast.accept(
                new ASTInterpreter(
                        new Empty<Binding>(),
                        new EvaluationPolicy(EvaluationType.BY_VALUE, EvaluationType.BY_NEED)
                        )
                );
    }

    /** Interprets the program using a call-by-name calling convention and a cons-by-need cons convention */
    public JamVal nameNeed() {
        Context.check(ast);
        return this.ast.accept(
                new ASTInterpreter(
                        new Empty<Binding>(),
                        new EvaluationPolicy(EvaluationType.BY_NAME, EvaluationType.BY_NEED)
                        )
                );
    }

    /** Interprets the program using a call-by-need calling convention and a cons-by-need cons convention */
    public JamVal needNeed() {
        Context.check(ast);
        return this.ast.accept(
                new ASTInterpreter(
                        new Empty<Binding>(),
                        new EvaluationPolicy(EvaluationType.BY_NEED, EvaluationType.BY_NEED)
                        )
                );
    }
    
}


