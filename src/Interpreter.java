import java.io.IOException;
import java.io.Reader;
import java.io.StringReader;

/** Jam Interpreter */
class Interpreter {
    
    public static void main(String[] args) {
        String program = "let x:ref ref int := ref ref 10; in {x<-ref 5;x}";
        //String program = "let x:list int := cons(10,cons(10,null:bool)); func:(->int) := map to 101; in func()";
        Interpreter i = new Interpreter(new StringReader(program));
        System.out.println(i.eagerEval());
    }

    /** Abstract Syntax Tree generated by the parser */
    private AST ast;

    /** Constructor */
    Interpreter(String fileName) throws IOException { this(new Parser(fileName)); }

    /** Constructor */
    Interpreter(Reader reader) { this(new Parser(reader)); }

    /** Constructor */
    Interpreter(Parser p) { this(p.parse()); }

    /** Constructor */
    Interpreter(AST ast) { this.ast = ast; }
    
    public static AST checkTypes(AST ast) {
        TypeCheck.check(ast);
        return ast;
    }

    /** Interprets the program using a call-by-value calling convention and a cons-by-value cons convention */
    public JamVal eagerEval() {
        ContextCheck.check(ast);
        TypeCheck.check(ast);
        return this.ast.accept(
                new ASTInterpreter(
                        new Empty<Binding>(),
                        new EvaluationPolicy(EvaluationType.BY_VALUE, EvaluationType.BY_VALUE)
                        )
                );
    }
    /** Interprets the program using a call-by-value calling convention and a cons-by-need cons convention */
    public JamVal lazyEval() {
        ContextCheck.check(ast);
        TypeCheck.check(ast);
        return this.ast.accept(
                new ASTInterpreter(
                        new Empty<Binding>(),
                        new EvaluationPolicy(EvaluationType.BY_VALUE, EvaluationType.BY_NEED)
                        )
                );
    }
}


